# -*- coding: utf-8 -*-
"""code for page curve quantum ising paper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12JFKl2m74hFe38znGv8SiAOqWsVhqU6C
"""

# config.py
# Central configuration file for the Page Curve QEC analysis project.

import networkx as nx
a
# --- 1. Simulation Control ---
# Standardize system size for a fair "Head-to-Head" comparison
N_SYS = 8

# Set number of runs for statistical averaging. 20 is a good number for a paper.
NUM_RUNS = 20
BASE_SEED = 2025 # Use a fixed seed for reproducibility

# Simulation time parameters
T_MAX = 20.0
T_STEPS = 150

# Data storage settings
DATA_DIR = "simulation_data_final"
RESULTS_FILE = f"{DATA_DIR}/results_N{N_SYS}.json"


# --- 2. Physics Parameters ---
# Default parameters that can be overridden by specific campaigns
PHYSICS_DEFAULTS = {
    'J_sys': 1.0,
    'g_bath': 0.5,
    'J_couple': 0.5,
    'N_bath': 2, # N_total will be N_sys + N_bath = 10
    'bath_noise_strength': 0.1,
}

# --- 3. Topology and Coupling Definitions (Standardized to N_sys=8) ---
def get_topologies_and_couplings():
    """Defines topologies and their respective coupling points to test."""
    topologies = {}
    # 1D Chain (N=8)
    topologies['1D Chain'] = {
        'graph': nx.path_graph(N_SYS),
        'coupling_points': {'end': 0} # Only one meaningful coupling type
    }
    # 2D Lattice (4x2, N=8)
    topologies['2D Lattice'] = {
        'graph': nx.convert_node_labels_to_integers(nx.grid_2d_graph(4, 2)),
        'coupling_points': {'corner': 0, 'middle': 2} # Node 2 is on the edge
    }
    # Heavy-Hex (N=8)
    G_hh = nx.Graph()
    G_hh.add_edges_from([(0,1), (2,3), (1,4), (3,5), (4,6), (5,7), (6,7)])
    topologies['Heavy-Hex'] = {
        'graph': G_hh,
        'coupling_points': {'degree-2_corner': 0, 'degree-3_middle': 1}
    }
    return topologies

# --- 4. Critical Point Definitions (for Initial State Preparation) ---
CRITICAL_POINTS = {
    '1D Chain': 1.0,
    '2D Lattice': 3.044,
    'Heavy-Hex': 2.25
}

# --- 5. Experimental Campaigns Definition ---
# Defines the experiments to run. For the focused paper, we only need one.
CAMPAIGNS = {
    'Effect of Coupling Strength': {
        'param_to_sweep': 'J_couple',
        'values': [0.2, 0.5, 1.0],
        'default_params': PHYSICS_DEFAULTS.copy()
    }
}

# generate_data.py
import numpy as np
import scipy.linalg as la
from numpy import kron
from tqdm import tqdm
import json
from pathlib import Path
import time
"""
from config import (
    NUM_RUNS, BASE_SEED, T_MAX, T_STEPS, CAMPAIGNS,
    get_topologies_and_couplings, CRITICAL_POINTS, RESULTS_FILE, DATA_DIR
)
"""
# --- Core Physics Engine ---
sigma_z, sigma_x = np.array([[1, 0], [0, -1]]), np.array([[0, 1], [1, 0]])

def get_operator(op, i, N):
    op_list = [np.identity(2) for _ in range(N)]
    if i < N: op_list[i] = op
    full_op = op_list[0]
    for k in range(1, N): full_op = kron(full_op, op_list[k])
    return full_op

def build_hamiltonian_from_graph(graph, J, g):
    N = graph.number_of_nodes()
    H = np.zeros((2**N, 2**N), dtype=np.complex128)
    for i, j in graph.edges():
        H += -J * (get_operator(sigma_z, i, N) @ get_operator(sigma_z, j, N))
    for i in range(N):
        H += -g * get_operator(sigma_x, i, N)
    return H

def run_single_realization(system_graph, g_sys_init, coupling_node, params, seed):
    N_sys = system_graph.number_of_nodes()
    N_bath = params['N_bath']
    N_total = N_sys + N_bath

    H_sys_isolated = build_hamiltonian_from_graph(system_graph, params['J_sys'], g_sys_init)
    _, evecs_sys = la.eigh(H_sys_isolated)
    gs_sys = evecs_sys[:, 0]

    bath_initial = np.zeros(2**N_bath); bath_initial[0] = 1.0
    psi_initial = kron(gs_sys, bath_initial)

    H_sys_full = kron(H_sys_isolated, np.identity(2**N_bath))

    rng = np.random.RandomState(seed)
    H_bath_full = np.zeros((2**N_total, 2**N_total), dtype=np.complex128)
    for i in range(N_sys, N_total):
        H_bath_full += -params['g_bath'] * get_operator(sigma_x, i, N_total)
        H_bath_full += rng.uniform(-params['bath_noise_strength'], params['bath_noise_strength']) * get_operator(sigma_z, i, N_total)

    H_coupling = -params['J_couple'] * (get_operator(sigma_z, coupling_node, N_total) @ get_operator(sigma_z, N_sys, N_total))
    H_total = H_sys_full + H_bath_full + H_coupling

    entanglement_evolution = []
    time_points = np.linspace(0, T_MAX, T_STEPS)
    for t in time_points:
        psi_t = la.expm(-1j * H_total * t) @ psi_initial
        psi_matrix = psi_t.reshape(2**N_sys, 2**N_bath)
        rho_A = np.dot(psi_matrix, psi_matrix.conj().T)
        eigenvalues = np.linalg.eigvalsh(rho_A)
        non_zero_eigenvalues = eigenvalues[eigenvalues > 1e-12]
        ee = -np.sum(non_zero_eigenvalues * np.log2(non_zero_eigenvalues))
        entanglement_evolution.append(ee)
    return time_points.tolist(), np.array(entanglement_evolution).tolist()

if __name__ == "__main__":
    Path(DATA_DIR).mkdir(exist_ok=True)
    topologies = get_topologies_and_couplings()
    results_data = {}

    print("--- Starting Rigorous Data Generation ---")
    total_start_time = time.time()

    for campaign_name, campaign_details in CAMPAIGNS.items():
        results_data[campaign_name] = {}
        param_to_sweep = campaign_details['param_to_sweep']
        param_values = campaign_details['values']

        for topo_name, topo_info in topologies.items():
            graph = topo_info['graph']
            results_data[campaign_name][topo_name] = {}
            g_init = CRITICAL_POINTS.get(topo_name, 1.0)

            for coupling_type, coupling_node in topo_info['coupling_points'].items():
                results_data[campaign_name][topo_name][coupling_type] = {}

                for val in param_values:
                    params = campaign_details['default_params'].copy()
                    params[param_to_sweep] = val

                    label = f"{topo_name}/{coupling_type}/{param_to_sweep}={val}"
                    all_runs_ee = []

                    for i in range(NUM_RUNS):
                        print(f"Running: {label} (Run {i+1}/{NUM_RUNS})")
                        seed = BASE_SEED + i
                        time_points, ee_data = run_single_realization(graph, g_init, coupling_node, params, seed)
                        all_runs_ee.append(ee_data)

                    results_data[campaign_name][topo_name][coupling_type][str(val)] = all_runs_ee

    results_data['time_points'] = time_points

    print(f"\n--- All simulations complete. Total time: {(time.time() - total_start_time)/60:.2f} minutes ---")
    print(f"--- Saving data to {RESULTS_FILE} ---")
    with open(RESULTS_FILE, 'w') as f:
        json.dump(results_data, f)
    print("--- Data generation finished successfully. ---")

# plot_results.py
import json
import numpy as np
import matplotlib.pyplot as plt
"""
from config import CAMPAIGNS, get_topologies_and_couplings, RESULTS_FILE
"""

def plot_dynamics_grid(campaign_name, campaign_data, time_points, topologies):
    """Generates the main grid of time-series plots."""
    campaign_config = CAMPAIGNS[campaign_name]
    param_sweep_values = campaign_config['values']
    param_sweep_name = campaign_config['param_to_sweep']

    num_topos = len(topologies)
    num_coupling_types = max(len(t['coupling_points']) for t in topologies.values())

    fig, axes = plt.subplots(num_coupling_types, num_topos, figsize=(8 * num_topos, 6 * num_coupling_types), sharex=True, squeeze=False)
    fig.suptitle(f'Campaign: {campaign_name}', fontsize=24, y=1.03)

    for col_idx, (topo_name, topo_info) in enumerate(topologies.items()):
        for row_idx, coupling_type in enumerate(topo_info['coupling_points'].keys()):
            ax = axes[row_idx, col_idx]
            plot_data = campaign_data[topo_name][coupling_type]

            for val in param_sweep_values:
                runs = np.array(plot_data[str(val)])
                mean_ee = np.mean(runs, axis=0)
                std_ee = np.std(runs, axis=0)

                label = f'{param_sweep_name.replace("_", " ")} = {val}'
                ax.plot(time_points, mean_ee, label=label)
                ax.fill_between(time_points, mean_ee - std_ee, mean_ee + std_ee, alpha=0.2)

            ax.set_title(f"{topo_name} (Coupling: {coupling_type})", fontsize=16)
            ax.grid(True, linestyle='--')
            ax.legend()
            ax.set_xlabel('Time ($t \cdot J_{sys}$)', fontsize=12)
            if col_idx == 0: ax.set_ylabel('System Entanglement Entropy (bits)', fontsize=12)

    for ax_row in axes:
        for ax in ax_row:
            if not ax.has_data(): ax.set_visible(False)

    plt.tight_layout(rect=[0, 0, 1, 0.97])
    plt.savefig(f"fig_{campaign_name.replace(' ', '_').lower()}.png", dpi=300, bbox_inches='tight')
    plt.show()

def plot_summary_barchart(campaign_name, campaign_data, topologies):
    """Generates a summary bar chart of peak entanglement."""
    campaign_config = CAMPAIGNS[campaign_name]
    param_sweep_values = campaign_config['values']

    labels = list(topologies.keys())
    x = np.arange(len(labels))
    width = 0.25

    fig, ax = plt.subplots(figsize=(14, 8))

    for i, val in enumerate(param_sweep_values):
        peak_means = []
        peak_errs = []
        for topo_name, topo_info in topologies.items():
            # For simplicity, we average over coupling points. Can be made more granular.
            all_peaks_for_topo = []
            for coupling_type in topo_info['coupling_points'].keys():
                runs = np.array(campaign_data[topo_name][coupling_type][str(val)])
                peak_per_run = np.max(runs, axis=1)
                all_peaks_for_topo.extend(peak_per_run)

            peak_means.append(np.mean(all_peaks_for_topo))
            peak_errs.append(np.std(all_peaks_for_topo))

        ax.bar(x + i*width - width, peak_means, width, yerr=peak_errs, label=f'J_couple = {val}', capsize=5)

    ax.set_ylabel('Peak Entanglement Entropy (bits)', fontsize=14)
    ax.set_title('Summary: Peak Entanglement by Topology and Coupling Strength', fontsize=18)
    ax.set_xticks(x)
    ax.set_xticklabels(labels, fontsize=12)
    ax.legend(fontsize=12)
    ax.grid(True, axis='y', linestyle='--')

    plt.tight_layout()
    plt.savefig("fig_peak_entanglement_summary.png", dpi=300, bbox_inches='tight')
    plt.show()

if __name__ == "__main__":
    plt.style.use('seaborn-v0_8-whitegrid')
    print("--- Loading data and generating plots ---")
    try:
        with open(RESULTS_FILE, 'r') as f:
            results = json.load(f)
    except FileNotFoundError:
        print(f"Error: Results file not found at {RESULTS_FILE}")
        print("Please run generate_data.py first.")
        exit()

    time_points = results.pop('time_points')
    topologies = get_topologies_and_couplings()

    for campaign_name, campaign_data in results.items():
        print(f"\nPlotting campaign: {campaign_name}")
        plot_dynamics_grid(campaign_name, campaign_data, time_points, topologies)
        # Create a summary bar chart only for the coupling strength campaign
        if campaign_name == 'Effect of Coupling Strength':
            plot_summary_barchart(campaign_name, campaign_data, topologies)

    print("\n--- Plot generation finished. ---")

# config.py
# Central configuration file for the Page Curve QEC analysis project.
# VERSION 2.1: Corrected 3D Lattice node labeling.

import networkx as nx

# --- 1. Simulation Control ---
# Standardize system size for a fair "Head-to-Head" comparison
N_SYS = 8

# Set number of runs for statistical averaging.
# Set to 3 for faster, exploratory analysis.
NUM_RUNS = 3
BASE_SEED = 2025 # Use a fixed seed for reproducibility

# Simulation time parameters
T_MAX = 20.0
T_STEPS = 150

# Data storage settings
DATA_DIR = "simulation_data_expanded"
RESULTS_FILE = f"{DATA_DIR}/results_expanded_N{N_SYS}.json"


# --- 2. Physics Parameters ---
# Default parameters that can be overridden by specific campaigns
PHYSICS_DEFAULTS = {
    'J_sys': 1.0,
    'g_bath': 0.5,
    'J_couple': 0.5,
    'N_bath': 2, # N_total will be N_sys + N_bath = 10
    'bath_noise_strength': 0.1,
}

# --- 3. Topology and Coupling Definitions (Standardized to N_sys=8) ---
def get_topologies_and_couplings():
    """Defines topologies and their respective coupling points to test."""
    topologies = {}

    # --- Existing Topologies ---
    topologies['1D Chain'] = {
        'graph': nx.path_graph(N_SYS),
        'coupling_points': {'end': 0}
    }
    topologies['2D Lattice'] = {
        'graph': nx.convert_node_labels_to_integers(nx.grid_2d_graph(4, 2)),
        'coupling_points': {'corner': 0, 'middle': 2}
    }
    G_hh = nx.Graph()
    G_hh.add_edges_from([(0,1), (2,3), (1,4), (3,5), (4,6), (5,7), (6,7)])
    topologies['Heavy-Hex'] = {
        'graph': G_hh,
        'coupling_points': {'degree-2_corner': 0, 'degree-3_middle': 1}
    }

    # --- New Topologies ---
    topologies['All-to-All'] = {
        'graph': nx.complete_graph(N_SYS),
        'coupling_points': {'symmetric_node': 0}
    }

    G_mod = nx.complete_graph(4)
    G_mod_2 = nx.complete_graph(4)
    G_mod = nx.union(G_mod, G_mod_2, rename=('M1-', 'M2-'))
    G_mod.add_edge('M1-0', 'M2-0')
    topologies['Modular'] = {
        'graph': nx.convert_node_labels_to_integers(G_mod),
        'coupling_points': {'bridge_node': 0, 'local_node': 1}
    }

    # A 3D Lattice (2x2x2 cube)
    # --- THIS SECTION IS CORRECTED ---
    G_3d_raw = nx.grid_graph(dim=[2, 2, 2])
    # The corner node (0,0,0) will be mapped to integer 0 by default.
    topologies['3D Lattice'] = {
        'graph': nx.convert_node_labels_to_integers(G_3d_raw),
        'coupling_points': {'corner': 0} # All nodes are symmetric corners
    }

    return topologies

# --- 4. Critical Point Definitions (for Initial State Preparation) ---
CRITICAL_POINTS = {
    '1D Chain': 1.0,
    '2D Lattice': 3.044,
    'Heavy-Hex': 2.25,
    'All-to-All': 7.0,
    'Modular': 3.5,
    '3D Lattice': 5.15
}

# --- 5. Experimental Campaigns Definition ---
CAMPAIGNS = {
    'Effect of Coupling Strength': {
        'param_to_sweep': 'J_couple',
        'values': [0.2, 0.5, 1.0],
        'default_params': PHYSICS_DEFAULTS.copy()
    }
}

# --- 6. Visualize Topologies for Verification ---
if __name__ == "__main__":
    # This block will only run when the script is executed directly
    # It allows for easy verification of the defined topologies
    import matplotlib.pyplot as plt

    print("--- Defined Network Topologies ---")

    # Get the dictionary of topologies
    all_topologies = get_topologies_and_couplings()

    # Loop through each topology to print its details and generate a plot
    for name, details in all_topologies.items():
        graph = details['graph']
        coupling_nodes = details['coupling_points'].values()

        # --- Print textual information ---
        print(f"\nTopology: {name}")
        print(f"  Edges: {list(graph.edges())}")
        print(f"  Number of nodes: {graph.number_of_nodes()}")
        print(f"  Coupling Points (nodes): {list(coupling_nodes)}")

        # --- Generate and save graph visualization ---
        plt.figure(figsize=(8, 6))

        # Define colors for nodes: red for coupling points, skyblue for others
        node_colors = ['red' if n in coupling_nodes else 'skyblue' for n in graph.nodes()]

        # --- CORRECTED SECTION ---
        # Define layout for the graph. Use a 2D layout for all graphs.
        if '2D' in name or '3D' in name or 'Heavy-Hex' in name or 'Modular' in name:
            pos = nx.spring_layout(graph)
        else:
            # Use circular layout for simpler or more symmetric graphs
            pos = nx.circular_layout(graph)
        # --- END CORRECTED SECTION ---

        nx.draw(graph, pos, with_labels=True, node_color=node_colors,
                node_size=800, font_size=12, font_weight='bold')

        plt.title(f"Topology: {name}", fontsize=16)

        # Save the figure to a file
        filename = f"topology_{name.replace(' ', '_').lower()}.png"
        plt.savefig(filename)
        print(f"  Saved graph image to: {filename}")

    # Show all plots at the end
    plt.show()

import networkx as nx
import matplotlib.pyplot as plt

# 1. Define a more representative 8-node Heavy-Hex fragment
# This fragment has nodes of degree 2 and 3, which is characteristic.
heavy_hex_graph = nx.Graph()
heavy_hex_edges = [
    (0, 1), (1, 2),
    (2, 3), (3, 7),
    (4, 5), (5, 6),
    (6, 7), (1, 5)
]
heavy_hex_graph.add_edges_from(heavy_hex_edges)

# Define the coupling points as in the original code for consistency
coupling_nodes = [0, 1]
node_colors = ['red' if n in coupling_nodes else 'skyblue' for n in heavy_hex_graph.nodes()]

# 2. Manually define the positions for each node to create the correct look
# This bypasses the spring_layout and enforces the geometry.
pos = {
    0: (0, 2), 1: (1, 1), 2: (2, 2), 3: (3, 1),
    4: (0, -2), 5: (1, -1), 6: (2, -2), 7: (2, 0)
}

# 3. Draw the graph with the specified positions
plt.figure(figsize=(8, 6))
nx.draw(
    heavy_hex_graph,
    pos,
    with_labels=True,
    node_color=node_colors,
    node_size=1500,
    font_size=16,
    font_weight='bold',
    width=2.0
)

plt.title("Accurate Heavy-Hex Topology (Manual Layout)", fontsize=20)
plt.margins(0.1) # Add some padding
plt.show()

# ==============================================================================
#
#  Combined Script for Defining and Visualizing Quantum System Topologies
#
# ==============================================================================

import networkx as nx
import matplotlib.pyplot as plt
from pathlib import Path

# --- 1. Simulation Control ---
# Standardize system size for a fair "Head-to-Head" comparison
N_SYS = 8

# Set number of runs for statistical averaging.
# Set to 3 for faster, exploratory analysis.
NUM_RUNS = 3
BASE_SEED = 2025 # Use a fixed seed for reproducibility

# Simulation time parameters
T_MAX = 20.0
T_STEPS = 150

# Data storage settings
DATA_DIR = "simulation_data_expanded"
RESULTS_FILE = f"{DATA_DIR}/results_expanded_N{N_SYS}.json"


# --- 2. Physics Parameters ---
# Default parameters that can be overridden by specific campaigns
PHYSICS_DEFAULTS = {
    'J_sys': 1.0,
    'g_bath': 0.5,
    'J_couple': 0.5,
    'N_bath': 2, # N_total will be N_sys + N_bath = 10
    'bath_noise_strength': 0.1,
}

# --- 3. Topology and Coupling Definitions (Standardized to N_sys=8) ---
def get_topologies_and_couplings():
    """Defines topologies and their respective coupling points to test."""
    topologies = {}

    # --- Standard Topologies ---
    topologies['1D Chain'] = {
        'graph': nx.path_graph(N_SYS),
        'coupling_points': {'end': 0}
    }
    topologies['2D Lattice'] = {
        'graph': nx.convert_node_labels_to_integers(nx.grid_2d_graph(4, 2)),
        'coupling_points': {'corner': 0, 'middle': 2}
    }

    # --- CORRECTED Heavy-Hex Topology Definition ---
    # This fragment has nodes of degree 2 and 3, which is characteristic.
    G_hh = nx.Graph()
    heavy_hex_edges = [
        (0, 1), (1, 2), (2, 3), (3, 7),
        (4, 5), (5, 6), (6, 7), (1, 5)
    ]
    G_hh.add_edges_from(heavy_hex_edges)
    topologies['Heavy-Hex'] = {
        'graph': G_hh,
        'coupling_points': {'degree-1_endpoint': 0, 'degree-3_heavy_node': 1}
    }

    # --- New Topologies ---
    topologies['All-to-All'] = {
        'graph': nx.complete_graph(N_SYS),
        'coupling_points': {'symmetric_node': 0}
    }

    G_mod = nx.complete_graph(4)
    G_mod_2 = nx.complete_graph(4)
    G_mod = nx.union(G_mod, G_mod_2, rename=('M1-', 'M2-'))
    G_mod.add_edge('M1-0', 'M2-0')
    topologies['Modular'] = {
        'graph': nx.convert_node_labels_to_integers(G_mod),
        'coupling_points': {'bridge_node': 0, 'local_node': 1}
    }

    # A 3D Lattice (2x2x2 cube)
    G_3d_raw = nx.grid_graph(dim=[2, 2, 2])
    topologies['3D Lattice'] = {
        'graph': nx.convert_node_labels_to_integers(G_3d_raw),
        'coupling_points': {'corner': 0} # All nodes are symmetric corners
    }

    return topologies

# --- 4. Critical Point Definitions (for Initial State Preparation) ---
CRITICAL_POINTS = {
    '1D Chain': 1.0,
    '2D Lattice': 3.044,
    'Heavy-Hex': 2.25, # Note: This value was for the original, incorrect graph
    'All-to-All': 7.0,
    'Modular': 3.5,
    '3D Lattice': 5.15
}

# --- 5. Experimental Campaigns Definition ---
CAMPAIGNS = {
    'Effect of Coupling Strength': {
        'param_to_sweep': 'J_couple',
        'values': [0.2, 0.5, 1.0],
        'default_params': PHYSICS_DEFAULTS.copy()
    }
}

# ==============================================================================
#
#  Main execution block to visualize and verify all defined topologies
#
# ==============================================================================
if __name__ == "__main__":

    # Create a directory for the output images if it doesn't exist
    Path("topology_images").mkdir(exist_ok=True)

    print("--- Defined Network Topologies ---")

    all_topologies = get_topologies_and_couplings()

    for name, details in all_topologies.items():
        graph = details['graph']
        coupling_nodes = details['coupling_points'].values()

        # --- Print textual information ---
        print(f"\nTopology: {name}")
        print(f"  Edges: {list(graph.edges())}")
        print(f"  Number of nodes: {graph.number_of_nodes()}")
        print(f"  Coupling Points (nodes): {list(coupling_nodes)}")

        # --- Generate and save graph visualization ---
        plt.figure(figsize=(8, 6))

        node_colors = ['red' if n in coupling_nodes else 'skyblue' for n in graph.nodes()]

        # --- Define Layouts: Special case for Heavy-Hex ---
        if name == 'Heavy-Hex':
            # Use the manually defined positions for an accurate geometric layout
            pos = {
                0: (0, 2), 1: (1, 1), 2: (2, 2), 3: (3, 1),
                4: (0, -2), 5: (1, -1), 6: (2, -2), 7: (2, 0)
            }
        elif '2D' in name or '3D' in name or 'Modular' in name:
            # Use a spring layout for other complex, non-linear graphs
            pos = nx.spring_layout(graph, seed=BASE_SEED)
        else:
            # Use a circular layout for 1D or fully-connected graphs
            pos = nx.circular_layout(graph)

        nx.draw(graph, pos, with_labels=True, node_color=node_colors,
                node_size=1200, font_size=14, font_weight='bold', width=1.5)

        plt.title(f"Topology: {name}", fontsize=18)

        # Save the figure to a file in the new directory
        filename = f"topology_images/topology_{name.replace(' ', '_').lower()}.png"
        plt.savefig(filename, bbox_inches='tight')
        print(f"  Saved graph image to: {filename}")
        plt.close() # Close figure to avoid displaying them all at once inline

    print("\n--- All topology images generated in the 'topology_images' folder. ---")

# ==============================================================================
#
#  generate_data.py: Single-Trial Run with Corrected Heavy-Hex (v2 - Fixed)
#
# ==============================================================================

import numpy as np
import scipy.linalg as la
from numpy import kron
from tqdm import tqdm
import json
from pathlib import Path
import time
import networkx as nx

# ==============================================================================
#  Integrated Configuration
# ==============================================================================

# --- 1. Simulation Control ---
N_SYS = 8
NUM_RUNS = 1 # Set to 1 for a single trial run
BASE_SEED = 2025
T_MAX = 20.0
T_STEPS = 150
DATA_DIR = "simulation_data_single_trial"
RESULTS_FILE = f"{DATA_DIR}/results_single_trial_N{N_SYS}.json"

# --- 2. Physics Parameters ---
PHYSICS_DEFAULTS = {
    'J_sys': 1.0,
    'g_bath': 0.5,
    'J_couple': 0.5,
    'N_bath': 2,
    'bath_noise_strength': 0.1,
}

# --- 3. Topology and Coupling Definitions ---
def get_topologies_and_couplings():
    """Defines topologies and their respective coupling points to test."""
    topologies = {}

    # Standard Topologies
    topologies['1D Chain'] = {
        'graph': nx.path_graph(N_SYS),
        'coupling_points': {'end': 0}
    }
    topologies['2D Lattice'] = {
        'graph': nx.convert_node_labels_to_integers(nx.grid_2d_graph(4, 2)),
        'coupling_points': {'corner': 0, 'middle': 2}
    }

    # CORRECTED Heavy-Hex Topology Definition
    G_hh = nx.Graph()
    heavy_hex_edges = [
        (0, 1), (1, 2), (2, 3), (3, 7),
        (4, 5), (5, 6), (6, 7), (1, 5)
    ]
    G_hh.add_edges_from(heavy_hex_edges)
    topologies['Heavy-Hex'] = {
        'graph': G_hh,
        'coupling_points': {'degree-1_endpoint': 0, 'degree-3_heavy_node': 1}
    }

    # Other Topologies
    topologies['All-to-All'] = {
        'graph': nx.complete_graph(N_SYS),
        'coupling_points': {'symmetric_node': 0}
    }
    G_mod = nx.complete_graph(4)
    G_mod_2 = nx.complete_graph(4)
    G_mod = nx.union(G_mod, G_mod_2, rename=('M1-', 'M2-'))
    G_mod.add_edge('M1-0', 'M2-0')
    topologies['Modular'] = {
        'graph': nx.convert_node_labels_to_integers(G_mod),
        'coupling_points': {'bridge_node': 0, 'local_node': 1}
    }
    G_3d_raw = nx.grid_graph(dim=[2, 2, 2])
    topologies['3D Lattice'] = {
        'graph': nx.convert_node_labels_to_integers(G_3d_raw),
        'coupling_points': {'corner': 0}
    }
    return topologies

# --- 4. Critical Point Definitions ---
CRITICAL_POINTS = {
    '1D Chain': 1.0,
    '2D Lattice': 3.044,
    'Heavy-Hex': 2.25, # Note: This value was for the original, incorrect graph
    'All-to-All': 7.0,
    'Modular': 3.5,
    '3D Lattice': 5.15
}

# --- 5. Experimental Campaigns Definition ---
CAMPAIGNS = {
    'Effect of Coupling Strength': {
        'param_to_sweep': 'J_couple',
        'values': [0.2, 0.5, 1.0],
        'default_params': PHYSICS_DEFAULTS.copy()
    }
}

# ==============================================================================
#  Core Physics Engine
# ==============================================================================
sigma_z, sigma_x = np.array([[1, 0], [0, -1]]), np.array([[0, 1], [1, 0]])

def get_operator(op, i, N):
    """Creates a full N-qubit operator acting with 'op' on qubit 'i'."""
    op_list = [np.identity(2) for _ in range(N)]
    if i < N: op_list[i] = op
    full_op = op_list[0]
    for k in range(1, N):
        full_op = kron(full_op, op_list[k])
    return full_op

def build_hamiltonian_from_graph(graph, J, g):
    N = graph.number_of_nodes()
    H = np.zeros((2**N, 2**N), dtype=np.complex128)
    for i, j in graph.edges():
        H += -J * (get_operator(sigma_z, i, N) @ get_operator(sigma_z, j, N))
    for i in range(N):
        H += -g * get_operator(sigma_x, i, N)
    return H

def run_single_realization(system_graph, g_sys_init, coupling_node, params, seed):
    N_sys = system_graph.number_of_nodes()
    N_bath = params['N_bath']
    N_total = N_sys + N_bath

    H_sys_isolated = build_hamiltonian_from_graph(system_graph, params['J_sys'], g_sys_init)
    _, evecs_sys = la.eigh(H_sys_isolated)
    gs_sys = evecs_sys[:, 0]

    bath_initial = np.zeros(2**N_bath); bath_initial[0] = 1.0
    psi_initial = kron(gs_sys, bath_initial)

    H_sys_full = kron(H_sys_isolated, np.identity(2**N_bath))

    rng = np.random.RandomState(seed)
    H_bath_full = np.zeros((2**N_total, 2**N_total), dtype=np.complex128)
    for i in range(N_sys, N_total):
        H_bath_full += -params['g_bath'] * get_operator(sigma_x, i, N_total)
        H_bath_full += rng.uniform(-params['bath_noise_strength'], params['bath_noise_strength']) * get_operator(sigma_z, i, N_total)

    H_coupling = -params['J_couple'] * (get_operator(sigma_z, coupling_node, N_total) @ get_operator(sigma_z, N_sys, N_total))
    H_total = H_sys_full + H_bath_full + H_coupling

    entanglement_evolution = []
    time_points = np.linspace(0, T_MAX, T_STEPS)
    for t in tqdm(time_points, desc="  Simulating time steps", leave=False):
        psi_t = la.expm(-1j * H_total * t) @ psi_initial
        psi_matrix = psi_t.reshape(2**N_sys, 2**N_bath)
        rho_A = np.dot(psi_matrix, psi_matrix.conj().T)
        eigenvalues = np.linalg.eigvalsh(rho_A)
        non_zero_eigenvalues = eigenvalues[eigenvalues > 1e-12]
        ee = -np.sum(non_zero_eigenvalues * np.log2(non_zero_eigenvalues))
        entanglement_evolution.append(ee)
    return time_points.tolist(), np.array(entanglement_evolution).tolist()

# ==============================================================================
#  Main Data Generation Script
# ==============================================================================
if __name__ == "__main__":
    Path(DATA_DIR).mkdir(exist_ok=True)
    topologies = get_topologies_and_couplings()
    results_data = {}

    print("--- Starting Data Generation (1 Trial Per Configuration) ---")
    total_start_time = time.time()

    for campaign_name, campaign_details in CAMPAIGNS.items():
        results_data[campaign_name] = {}
        param_to_sweep = campaign_details['param_to_sweep']
        param_values = campaign_details['values']

        for topo_name, topo_info in topologies.items():
            graph = topo_info['graph']
            results_data[campaign_name][topo_name] = {}

            # --- THIS LINE IS NOW CORRECTED ---
            g_init = CRITICAL_POINTS.get(topo_name, 1.0)

            for coupling_type, coupling_node in topo_info['coupling_points'].items():
                results_data[campaign_name][topo_name][coupling_type] = {}

                for val in param_values:
                    params = campaign_details['default_params'].copy()
                    params[param_to_sweep] = val

                    label = f"{topo_name}/{coupling_type}/{param_to_sweep}={val}"
                    all_runs_ee = []

                    # Since NUM_RUNS is 1, this loop will only run once.
                    print(f"\nRunning Configuration: {label}")
                    for i in range(NUM_RUNS):
                        seed = BASE_SEED + i
                        time_points, ee_data = run_single_realization(graph, g_init, coupling_node, params, seed)
                        all_runs_ee.append(ee_data)

                    results_data[campaign_name][topo_name][coupling_type][str(val)] = all_runs_ee

    results_data['time_points'] = time_points

    print(f"\n--- All simulations complete. Total time: {(time.time() - total_start_time)/60:.2f} minutes ---")
    print(f"--- Saving data to {RESULTS_FILE} ---")
    with open(RESULTS_FILE, 'w') as f:
        json.dump(results_data, f, indent=4)
    print("--- Data generation finished successfully. ---")

# generate_data.py
import numpy as np
import scipy.linalg as la
from numpy import kron
from tqdm import tqdm
import json
from pathlib import Path
import time
import networkx as nx
"""
from config import (
    NUM_RUNS, BASE_SEED, T_MAX, T_STEPS, CAMPAIGNS,
    get_topologies_and_couplings, CRITICAL_POINTS, RESULTS_FILE, DATA_DIR
)
"""
# --- Core Physics Engine ---
sigma_z, sigma_x = np.array([[1, 0], [0, -1]]), np.array([[0, 1], [1, 0]])

def get_operator(op, i, N):
    """Creates a full N-qubit operator acting with 'op' on qubit 'i'."""
    op_list = [np.identity(2) for _ in range(N)]
    if i < N: op_list[i] = op
    full_op = op_list[0]
    for k in range(1, N):
        full_op = kron(full_op, op_list[k])
    return full_op

def build_hamiltonian_from_graph(graph, J, g):
    N = graph.number_of_nodes()
    H = np.zeros((2**N, 2**N), dtype=np.complex128)
    for i, j in graph.edges():
        H += -J * (get_operator(sigma_z, i, N) @ get_operator(sigma_z, j, N))
    for i in range(N):
        H += -g * get_operator(sigma_x, i, N)
    return H

def run_single_realization(system_graph, g_sys_init, coupling_node, params, seed):
    N_sys = system_graph.number_of_nodes()
    N_bath = params['N_bath']
    N_total = N_sys + N_bath

    H_sys_isolated = build_hamiltonian_from_graph(system_graph, params['J_sys'], g_sys_init)
    _, evecs_sys = la.eigh(H_sys_isolated)
    gs_sys = evecs_sys[:, 0]

    bath_initial = np.zeros(2**N_bath); bath_initial[0] = 1.0
    psi_initial = kron(gs_sys, bath_initial)

    H_sys_full = kron(H_sys_isolated, np.identity(2**N_bath))

    rng = np.random.RandomState(seed)
    H_bath_full = np.zeros((2**N_total, 2**N_total), dtype=np.complex128)
    for i in range(N_sys, N_total):
        H_bath_full += -params['g_bath'] * get_operator(sigma_x, i, N_total)
        H_bath_full += rng.uniform(-params['bath_noise_strength'], params['bath_noise_strength']) * get_operator(sigma_z, i, N_total)

    H_coupling = -params['J_couple'] * (get_operator(sigma_z, coupling_node, N_total) @ get_operator(sigma_z, N_sys, N_total))
    H_total = H_sys_full + H_bath_full + H_coupling

    entanglement_evolution = []
    time_points = np.linspace(0, T_MAX, T_STEPS)
    for t in time_points:
        psi_t = la.expm(-1j * H_total * t) @ psi_initial
        psi_matrix = psi_t.reshape(2**N_sys, 2**N_bath)
        rho_A = np.dot(psi_matrix, psi_matrix.conj().T)
        eigenvalues = np.linalg.eigvalsh(rho_A)
        non_zero_eigenvalues = eigenvalues[eigenvalues > 1e-12]
        ee = -np.sum(non_zero_eigenvalues * np.log2(non_zero_eigenvalues))
        entanglement_evolution.append(ee)
    return time_points.tolist(), np.array(entanglement_evolution).tolist()


# --- Main Data Generation Script ---
if __name__ == "__main__":
    Path(DATA_DIR).mkdir(exist_ok=True)
    topologies = get_topologies_and_couplings()
    results_data = {}

    print("--- Starting Rigorous Data Generation ---")
    total_start_time = time.time()

    for campaign_name, campaign_details in CAMPAIGNS.items():
        results_data[campaign_name] = {}
        param_to_sweep = campaign_details['param_to_sweep']
        param_values = campaign_details['values']

        for topo_name, topo_info in topologies.items():
            graph = topo_info['graph']
            results_data[campaign_name][topo_name] = {}
            g_init = CRITICAL_POINTS.get(topo_name, 1.0)

            for coupling_type, coupling_node in topo_info['coupling_points'].items():
                results_data[campaign_name][topo_name][coupling_type] = {}

                for val in param_values:
                    params = campaign_details['default_params'].copy()
                    params[param_to_sweep] = val

                    label = f"{topo_name}/{coupling_type}/{param_to_sweep}={val}"
                    all_runs_ee = []

                    print(f"Running Configuration: {label}")
                    for i in tqdm(range(NUM_RUNS), desc=f"  Runs for {val}"):
                        seed = BASE_SEED + i
                        time_points, ee_data = run_single_realization(graph, g_init, coupling_node, params, seed)
                        all_runs_ee.append(ee_data)

                    results_data[campaign_name][topo_name][coupling_type][str(val)] = all_runs_ee

    results_data['time_points'] = time_points

    print(f"\n--- All simulations complete. Total time: {(time.time() - total_start_time)/60:.2f} minutes ---")
    print(f"--- Saving data to {RESULTS_FILE} ---")
    with open(RESULTS_FILE, 'w') as f:
        json.dump(results_data, f)
    print("--- Data generation finished successfully. ---")

# plot_results.py
import json
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
#from config import CAMPAIGNS, get_topologies_and_couplings, RESULTS_FILE, DATA_DIR

def plot_dynamics_grid(campaign_name, campaign_data, time_points, topologies):
    """Generates the main grid of time-series plots."""
    campaign_config = CAMPAIGNS[campaign_name]
    param_sweep_values = campaign_config['values']
    param_sweep_name = campaign_config['param_to_sweep']

    num_topos = len(topologies)
    # Check max number of coupling points for subplot rows
    num_coupling_types = max(len(t['coupling_points']) for t in topologies.values())

    fig, axes = plt.subplots(
        num_coupling_types, num_topos,
        figsize=(7 * num_topos, 5 * num_coupling_types),
        sharey='row', sharex=True, squeeze=False
    )
    fig.suptitle(f'Campaign: {campaign_name}', fontsize=24, y=1.03)

    topo_keys = list(topologies.keys())

    for col_idx, topo_name in enumerate(topo_keys):
        topo_info = topologies[topo_name]
        coupling_types = topo_info['coupling_points']

        for row_idx, coupling_type in enumerate(coupling_types.keys()):
            ax = axes[row_idx, col_idx]
            plot_data = campaign_data.get(topo_name, {}).get(coupling_type, {})
            if not plot_data:
                ax.set_visible(False)
                continue

            for val in param_sweep_values:
                runs = np.array(plot_data[str(val)])
                mean_ee = np.mean(runs, axis=0)
                std_ee = np.std(runs, axis=0)

                label = f'{param_sweep_name.replace("_", " ")} = {val}'
                ax.plot(time_points, mean_ee, label=label)
                ax.fill_between(time_points, mean_ee - std_ee, mean_ee + std_ee, alpha=0.2)

            ax.set_title(f"{topo_name} (Coupling: {coupling_type})", fontsize=16)
            ax.grid(True, linestyle='--')
            ax.legend()
            ax.set_xlabel('Time ($t \cdot J_{sys}$)', fontsize=12)
            if col_idx == 0: ax.set_ylabel('System Entanglement Entropy (bits)', fontsize=12)

    # Make empty plots invisible
    for i, topo_name in enumerate(topo_keys):
        if len(topologies[topo_name]['coupling_points']) < num_coupling_types:
            for j in range(len(topologies[topo_name]['coupling_points']), num_coupling_types):
                axes[j,i].set_visible(False)

    plt.tight_layout(rect=[0, 0, 1, 0.97])
    plt.savefig(f"fig_{campaign_name.replace(' ', '_').lower()}.png", dpi=300, bbox_inches='tight')
    plt.show()

def plot_summary_barchart(campaign_name, campaign_data, topologies):
    """Generates a summary bar chart of peak entanglement."""
    campaign_config = CAMPAIGNS[campaign_name]
    param_sweep_values = campaign_config['values']

    labels = list(topologies.keys())
    x = np.arange(len(labels))
    num_params = len(param_sweep_values)
    width = 0.8 / num_params

    fig, ax = plt.subplots(figsize=(16, 9))

    for i, val in enumerate(param_sweep_values):
        peak_means = []
        peak_errs = []
        for topo_name, topo_info in topologies.items():
            all_peaks_for_topo = []
            # Average over all coupling points for a single bar per topology
            for coupling_type in topo_info['coupling_points'].keys():
                runs = np.array(campaign_data[topo_name][coupling_type][str(val)])
                peak_per_run = np.max(runs, axis=1)
                all_peaks_for_topo.extend(peak_per_run)

            peak_means.append(np.mean(all_peaks_for_topo))
            peak_errs.append(np.std(all_peaks_for_topo))

        offset = width * i - width * (num_params - 1) / 2
        ax.bar(x + offset, peak_means, width, yerr=peak_errs, label=f'J_couple = {val}', capsize=4)

    ax.set_ylabel('Peak Entanglement Entropy (bits)', fontsize=14)
    ax.set_title('Summary: Peak Entanglement by Topology and Coupling Strength', fontsize=18)
    ax.set_xticks(x)
    ax.set_xticklabels(labels, fontsize=12, rotation=15, ha="right")
    ax.legend(fontsize=12)
    ax.grid(True, axis='y', linestyle='--')

    plt.tight_layout()
    plt.savefig("fig_peak_entanglement_summary.png", dpi=300, bbox_inches='tight')
    plt.show()

if __name__ == "__main__":
    plt.style.use('seaborn-v0_8-whitegrid')
    print("--- Loading data and generating plots ---")
    try:
        with open(RESULTS_FILE, 'r') as f:
            results = json.load(f)
    except FileNotFoundError:
        print(f"Error: Results file not found at {RESULTS_FILE}")
        print("Please run generate_data.py first.")
        exit()

    time_points = results.pop('time_points')
    topologies = get_topologies_and_couplings()

    for campaign_name, campaign_data in results.items():
        print(f"\nPlotting campaign: {campaign_name}")
        plot_dynamics_grid(campaign_name, campaign_data, time_points, topologies)
        if campaign_name == 'Effect of Coupling Strength':
            plot_summary_barchart(campaign_name, campaign_data, topologies)

    print("\n--- Plot generation finished. ---")

# plot_results.py
# VERSION 2: Generates distinct, individual plots for each experimental condition
# and a more detailed summary bar chart for maximum clarity.

import json
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from pathlib import Path

# We still need the config to understand the experiment structure
#from config import CAMPAIGNS, get_topologies_and_couplings, RESULTS_FILE, DATA_DIR

def plot_individual_dynamics(topo_name, coupling_type, plot_data, time_points, campaign_config):
    """
    Generates and saves a single, distinct plot for one topology/coupling configuration.
    """
    param_sweep_name = campaign_config['param_to_sweep']
    param_sweep_values = campaign_config['values']

    plt.figure(figsize=(11, 7))
    ax = plt.gca()

    for val in param_sweep_values:
        runs = np.array(plot_data[str(val)])
        mean_ee = np.mean(runs, axis=0)
        std_ee = np.std(runs, axis=0)

        label = f'{param_sweep_name.replace("_", " ").title()} = {val}'
        ax.plot(time_points, mean_ee, label=label, lw=2)
        ax.fill_between(time_points, mean_ee - std_ee, mean_ee + std_ee, alpha=0.2)

    ax.set_title(f"Entanglement Dynamics for {topo_name}\n(Coupling at {coupling_type} node)", fontsize=18)
    ax.grid(True, linestyle='--')
    ax.legend(fontsize=12)
    ax.set_xlabel('Time ($t \cdot J_{sys}$)', fontsize=14)
    ax.set_ylabel('System Entanglement Entropy (bits)', fontsize=14)
    ax.tick_params(axis='both', which='major', labelsize=12)

    # Save the individual figure
    output_filename = f"fig_dynamics_{topo_name}_{coupling_type}.png"
    plt.savefig(output_filename, dpi=300, bbox_inches='tight')
    print(f"  Saved individual plot: {output_filename}")
    plt.close() # Close the figure to avoid displaying it in-line with the next one

def plot_detailed_summary_barchart(campaign_data, topologies):
    """
    Generates a detailed summary bar chart that shows each coupling type separately.
    """
    # This assumes the campaign is 'Effect of Coupling Strength'
    param_sweep_values = CAMPAIGNS['Effect of Coupling Strength']['values']

    # --- Data Preparation ---
    # Create a unique label for each bar group, e.g., "2D Lattice (corner)"
    group_labels = []
    peak_means_by_j = {val: [] for val in param_sweep_values}
    peak_errs_by_j = {val: [] for val in param_sweep_values}

    for topo_name, topo_info in topologies.items():
        for coupling_type in topo_info['coupling_points'].keys():
            group_labels.append(f"{topo_name}\n({coupling_type})")

            for val in param_sweep_values:
                runs = np.array(campaign_data[topo_name][coupling_type][str(val)])
                # Find the peak entanglement for each individual run
                peak_per_run = np.max(runs, axis=1)

                peak_means_by_j[val].append(np.mean(peak_per_run))
                peak_errs_by_j[val].append(np.std(peak_per_run))

    # --- Plotting ---
    x = np.arange(len(group_labels))
    num_params = len(param_sweep_values)
    width = 0.8 / num_params

    fig, ax = plt.subplots(figsize=(18, 10))

    for i, val in enumerate(param_sweep_values):
        offset = width * i - width * (num_params - 1) / 2
        means = peak_means_by_j[val]
        errors = peak_errs_by_j[val]
        ax.bar(x + offset, means, width, yerr=errors, label=f'J_couple = {val}', capsize=4)

    ax.set_ylabel('Peak Entanglement Entropy (bits)', fontsize=16)
    ax.set_title('Summary: Peak Entanglement by Topology and Coupling Configuration', fontsize=20)
    ax.set_xticks(x)
    ax.set_xticklabels(group_labels, fontsize=12, rotation=15, ha="right")
    ax.legend(title="Coupling Strength", fontsize=12)
    ax.grid(True, axis='y', linestyle='--', which='both')

    plt.tight_layout()
    plt.savefig("fig_peak_entanglement_summary_detailed.png", dpi=300, bbox_inches='tight')
    print(f"\n  Saved detailed summary bar chart: fig_peak_entanglement_summary_detailed.png")
    plt.show()
    plt.close()

if __name__ == "__main__":
    plt.style.use('seaborn-v0_8-whitegrid')
    print("--- Loading data and generating plots ---")

    # Create a directory for the figures
    Path("figures").mkdir(exist_ok=True)

    try:
        with open(RESULTS_FILE, 'r') as f:
            results = json.load(f)
    except FileNotFoundError:
        print(f"Error: Results file not found at {RESULTS_FILE}")
        print("Please run generate_data.py first.")
        exit()

    time_points = results.pop('time_points')
    topologies = get_topologies_and_couplings()

    # --- Generate all individual dynamics plots ---
    print("\n--- Generating individual dynamics plots for each configuration ---")
    for campaign_name, campaign_data in results.items():
        if campaign_name != 'Effect of Coupling Strength': continue

        for topo_name, topo_data in campaign_data.items():
            for coupling_type, coupling_data in topo_data.items():
                plot_individual_dynamics(
                    topo_name, coupling_type, coupling_data,
                    time_points, CAMPAIGNS[campaign_name]
                )

    # --- Generate the final summary bar chart ---
    print("\n--- Generating detailed summary bar chart ---")
    plot_detailed_summary_barchart(results['Effect of Coupling Strength'], topologies)

    print("\n--- Plot generation finished. Figures saved to current directory. ---")